/*
 * Note: this file originally auto-generated by mib2c using mib2c.scalar.conf
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "guyCole.h"

static u_long gcSimpleInteger = 0;

#define DISPLAY_STRING_MAX 32
static char gcSimpleString[DISPLAY_STRING_MAX];

/** Initializes the guyCole module */
void init_guyCole(void) {
  const oid gcSimpleInteger_oid[] = { 1,3,6,1,4,1,5088,1,1 };
  const oid gcSimpleString_oid[] = { 1,3,6,1,4,1,5088,1,2 };

  netsnmp_handler_registration *simple_integer;
  netsnmp_handler_registration *simple_string;

  DEBUGMSGTL(("guyCole", "initializing\n"));

  gcSimpleInteger = 321;
  strcpy(gcSimpleString, "firstValue");

  simple_integer = netsnmp_create_handler_registration("gcSimpleInteger", handle_gcSimpleInteger, gcSimpleInteger_oid, OID_LENGTH(gcSimpleInteger_oid), HANDLER_CAN_RWRITE);
  netsnmp_register_scalar(simple_integer);

  simple_string = netsnmp_create_handler_registration("gcSimpleString", handle_gcSimpleString, gcSimpleString_oid, OID_LENGTH(gcSimpleString_oid), HANDLER_CAN_RWRITE);
  netsnmp_register_scalar(simple_string);
}

int handle_gcSimpleInteger(
  netsnmp_mib_handler          *handler,
  netsnmp_handler_registration *reginfo,
  netsnmp_agent_request_info   *reqinfo,
  netsnmp_request_info         *requests) {

  int retval;
  u_long undo_buffer;

  DEBUGMSGTL(("guyCole", "handleInteger\n"));

  switch(reqinfo->mode) {
    case MODE_GET:
      DEBUGMSGTL(("guyCole", "get\n"));
      snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &gcSimpleInteger, sizeof(u_long));
      break;

    case MODE_SET_RESERVE1:
      DEBUGMSGTL(("guyCole", "reserve1\n"));
      retval = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
      if (retval != SNMP_ERR_NOERROR) {
        netsnmp_set_request_error(reqinfo, requests, retval);
      }
      break;

    case MODE_SET_RESERVE2:
      DEBUGMSGTL(("guyCole", "reserve2\n"));
      undo_buffer = gcSimpleInteger;
      break;

    case MODE_SET_FREE:
      DEBUGMSGTL(("guyCole", "set free\n"));
      break;

    case MODE_SET_ACTION:
      DEBUGMSGTL(("guyCole", "set action\n"));
      gcSimpleInteger = *(requests->requestvb->val.integer);
      DEBUGMSGTL(("guyCole", "updated integer -> %u\n", gcSimpleInteger));
      break;

    case MODE_SET_COMMIT:
      DEBUGMSGTL(("guyCole", "set commit\n"));
      break;

    case MODE_SET_UNDO:
      DEBUGMSGTL(("guyCole", "set undo\n"));
      gcSimpleInteger = undo_buffer;
      break;

    default:
      // should never get here
      snmp_log(LOG_ERR, "unknown mode (%d) in  handle_gcSimpleInteger\n", reqinfo->mode );
      return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_gcSimpleString(
  netsnmp_mib_handler          *handler,
  netsnmp_handler_registration *reginfo,
  netsnmp_agent_request_info   *reqinfo,
  netsnmp_request_info         *requests) {

  int ret;

  DEBUGMSGTL(("guyCole", "handleString\n"));

  switch(reqinfo->mode) {
    case MODE_GET:
      snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *) gcSimpleString, DISPLAY_STRING_MAX);
      break;


        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1: 
          DEBUGMSGTL(("guyCole", "reserve1\n"));

                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            DEBUGMSGTL(("guyCole", "reserve2\n"));
            /* XXX malloc "undo" storage buffer */
            if (/* XXX if malloc, or whatever, failed: */) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
            if (/* XXX: error? */) {
                netsnmp_set_request_error(reqinfo, requests, /* some error */);
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            if (/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
            }
            break;

    default:
      // we should never get here
      snmp_log(LOG_ERR, "unknown mode (%d) in handle_gcSimpleString\n", reqinfo->mode);
      return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
